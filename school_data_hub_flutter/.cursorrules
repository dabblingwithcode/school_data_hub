# Cursor Rules for School Data Hub Flutter Project

Please think out loud and provide 
- Overview of completed work
- Rationale for decision
- next steps checklist

## Dart and flutter rules

- always use package import even for our project files
  - Comply to the always_use_package_imports rule
- prefer composability breaking down presentation files:
  - creating/ using a "widgets" folder in the page/widget folder
  - creating the broken-down widget in a new file in the widgets folder
- important: don't create model classes without asking! Reason and request it before you do it!
- Prefer using a WatchingWidget creating listenables with the createOnce function over stateful widgets!

## Project Overview
This is a Flutter application for School Data Hub with Serverpod backend integration. The project uses modern Flutter development practices and follows a feature-based architecture.

## Architecture Guidelines

### Project Structure
- `lib/features/` - Feature-based modules with their own models, views, and controllers
- `lib/core/` - Core utilities, constants, and shared functionality
- `lib/common/` - Common widgets and utilities used across features
- `lib/app_utils/` - Application-level utilities and helpers
- `lib/l10n/` - Localization files
- every feature contains `data`, `domain` and `presentation` folders.

### Code Organization
- Use feature-based architecture with clear separation of concerns
- 
- Follow the repository pattern for data access
- Implement proper state management using the watch_it package
- Use dependency injection for service management

### Handling DateTime values
- The server works with utc format. Every datetime landing in the server should be in utc format.
- The managers must work with utc format too because there objects are created and updated.
- The presentation layer must be responsible for the conversion .toLocal().
- Managers receiving DateTime objects from the presentation layer must convert them to utc before manipulating / creating objects.
- This is valid for every manager, common or feature
- This has high priority and you are allowed to tackle this if it comes you across.

## Package Documentation and Usage Guidelines

- include context from the packages where relevant from the `cursor_docs`folder in the file with the package name.
- 
### Core Dependencies

#### serverpod_flutter (2.9.1)
- **Purpose**: Backend integration with Serverpod
- **Usage**: Use for API calls, real-time communication, and data synchronization
- **Best Practices**: 
  - Always handle connection states
  - Use proper error handling for network calls
  - Implement retry logic for failed requests

#### school_data_hub_client
- **Purpose**: Local client package for School Data Hub
- **Usage**: Import and use for local data operations
- **Note**: This is a local path dependency

#### watch_it (1.7.0)
- **Purpose**: Dependency injection and state management
- **Usage**: 
  - Register services with `GetIt.instance.registerSingleton()`
  - Implement proper disposal of services

#### flutter_secure_storage (10.0.0-beta.1)
- **Purpose**: Secure storage for sensitive data
- **Usage**: Store authentication tokens, encryption keys, and sensitive user data
- **Best Practices**:
  - Always handle encryption/decryption errors
  - Use proper key management
  - Clear sensitive data on logout

### UI and Navigation

#### gap (3.0.1)
- **Purpose**: Consistent spacing between widgets
- **Usage**: Use `Gap()` widget for consistent vertical/horizontal spacing
- **Best Practices**: Define spacing constants in your theme

#### carousel_slider (5.0.0)
- **Purpose**: Image carousel and slider functionality
- **Usage**: Display multiple images or content in a scrollable format
- **Best Practices**: Implement proper loading states and error handling

#### table_calendar (3.1.3) & calendar_date_picker2 (2.0.1)
- **Purpose**: Calendar functionality for date selection
- **Usage**: Date picking, event display, and calendar views
- **Best Practices**: Handle timezone differences and date formatting

### File and Media Handling

#### file_picker (10.1.9)
- **Purpose**: File selection from device
- **Usage**: Allow users to pick files from their device
- **Best Practices**: 
  - Validate file types and sizes
  - Handle permissions properly
  - Show loading states during file operations

#### image_picker (1.1.2)
- **Purpose**: Image selection from camera or gallery
- **Usage**: Capture or select images
- **Best Practices**: 
  - Request camera permissions
  - Compress images for better performance
  - Handle image orientation

#### crop_image (1.0.16) & custom_image_crop (0.1.1)
- **Purpose**: Image cropping functionality
- **Usage**: Allow users to crop selected images
- **Best Practices**: Maintain aspect ratios and provide preview

#### mobile_scanner (7.0.1) & qr_flutter (4.1.0) & qr_code_vision (0.1.2)
- **Purpose**: QR code scanning and generation
- **Usage**: 
  - `mobile_scanner`: Scan QR codes using camera
  - `qr_flutter`: Generate QR codes
  - `qr_code_vision`: Read QR codes from images (Windows compatibility)
- **Best Practices**: Handle camera permissions and provide fallback options

### Data and Security

#### encrypt (5.0.3) & cryptography_plus (2.7.1)
- **Purpose**: Data encryption and security
- **Usage**: Encrypt sensitive data before storage or transmission
- **Best Practices**: 
  - Use strong encryption algorithms
  - Secure key management
  - Never store encryption keys in plain text

#### json_annotation (4.9.0) & json_serializable (6.8.0)
- **Purpose**: JSON serialization/deserialization
- **Usage**: Convert Dart objects to/from JSON
- **Best Practices**: 
  - Use `@JsonSerializable()` annotation
  - Run `flutter packages pub run build_runner build` after changes
  - Handle null values properly

#### jwt_decoder (2.0.1)
- **Purpose**: JWT token decoding
- **Usage**: Extract information from JWT tokens
- **Best Practices**: Validate token expiration and signature

### PDF and Printing

#### pdf (3.11.3) & printing (5.14.2)
- **Purpose**: PDF generation and printing
- **Usage**: Create PDF documents and print functionality
- **Best Practices**: 
  - Handle large documents efficiently
  - Provide progress indicators
  - Test on different platforms

### Network and HTTP

#### dio (5.8.0+1)
- **Purpose**: HTTP client for network requests
- **Usage**: Make HTTP requests with advanced features
- **Best Practices**: 
  - Configure interceptors for authentication
  - Handle timeouts and retries
  - Implement proper error handling

#### url_launcher (6.3.1)
- **Purpose**: Launch URLs in browser or apps
- **Usage**: Open external links and deep links
- **Best Practices**: Validate URLs before launching

### Platform Specific

#### window_manager (0.5.0)
- **Purpose**: Desktop window management
- **Usage**: Control window size, position, and behavior on desktop
- **Best Practices**: Respect user preferences and accessibility settings

#### flutter_secure_storage (10.0.0-beta.1)
- **Purpose**: Platform-specific secure storage
- **Usage**: Store sensitive data securely on each platform
- **Best Practices**: Handle platform differences gracefully

### Development and Build

#### flutter_launcher_icons (0.14.3)
- **Purpose**: Generate app icons
- **Usage**: Configure app icons for different platforms
- **Best Practices**: Provide high-resolution source images

#### shorebird_code_push (2.0.4)
- **Purpose**: Code push updates for Flutter apps
- **Usage**: Deploy updates without app store approval
- **Best Practices**: Test updates thoroughly before deployment

## Coding Standards

### Dart/Flutter Best Practices
- Use `const` constructors where possible
- Implement proper error handling with try-catch blocks
- Use meaningful variable and function names
- Add documentation comments for public APIs
- Follow Flutter's style guide

### Watch_it Best Practices
- **NEVER use watch methods conditionally** - this is bad practice and can cause issues with the reactive system
- Always call watch methods at the top level of the build method, not inside conditional statements
- Use proper null checks and default values instead of conditional watching
- Example of bad practice: `if (condition) watchPropertyValue(...)`
- Example of good practice: `final value = watchPropertyValue(...) ?? defaultValue`

### State Management
- Use `watch_it` for dependency injection
- Avoid listenable builders
- Implement proper state management patterns
- Avoid global state when possible
- Use `ChangeNotifier` or similar for reactive UI updates

### Error Handling
- Always handle async operations with proper error handling
- Provide user-friendly error messages
- Log errors appropriately using the `logging` package
- Implement retry mechanisms for network operations

### Performance
- Use `ListView.builder` for large lists
- Implement proper image caching with `flutter_cache_manager`
- Avoid unnecessary widget rebuilds
- Use `const` widgets where possible

### Security
- Never hardcode sensitive information
- Use `flutter_secure_storage` for sensitive data
- Validate all user inputs
- Implement proper authentication flows

### Testing
- Write unit tests for business logic
- Use `flutter_test` for widget testing
- Test error scenarios and edge cases
- Maintain good test coverage

### Localization
- Use `flutter_localizations` for internationalization
- Store all strings in localization files
- Support RTL languages if needed
- Use `intl` package for date/number formatting

## Development Workflow
1. Follow feature-based development
2. Use proper branching strategy
3. Write tests for new features
4. Update documentation when adding new packages
5. Run `flutter analyze` before committing
6. Use `build_runner` for code generation

## Common Commands
- `flutter pub get` - Install dependencies
- `flutter packages pub run build_runner build` - Generate code
- `flutter analyze` - Run static analysis
- `flutter test` - Run tests
- `flutter build` - Build for target platform
